<?php
/**
 * ServiceCollectionApi
 * PHP version 5
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PTV Open Api version 11
 *
 * Here you can see listed all the PTV Open Api methods.
 *
 * OpenAPI spec version: v11
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.29
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Tampere\PtvV11\PtvApi;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Query;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Tampere\PtvV11\ApiException;
use Tampere\PtvV11\Configuration;
use Tampere\PtvV11\HeaderSelector;
use Tampere\PtvV11\ObjectSerializer;

/**
 * ServiceCollectionApi Class Doc Comment
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ServiceCollectionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiV11ServiceCollectionGet
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceCollectionGet($date = null, $dateBefore = null, $page = '1', $archived = 'false')
    {
        list($response) = $this->apiV11ServiceCollectionGetWithHttpInfo($date, $dateBefore, $page, $archived);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionGetWithHttpInfo
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionGetWithHttpInfo($date = null, $dateBefore = null, $page = '1', $archived = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceCollectionGetRequest($date, $dateBefore, $page, $archived);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionGetAsync
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionGetAsync($date = null, $dateBefore = null, $page = '1', $archived = 'false')
    {
        return $this->apiV11ServiceCollectionGetAsyncWithHttpInfo($date, $dateBefore, $page, $archived)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionGetAsyncWithHttpInfo
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionGetAsyncWithHttpInfo($date = null, $dateBefore = null, $page = '1', $archived = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceCollectionGetRequest($date, $dateBefore, $page, $archived);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionGet'
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceCollectionGetRequest($date = null, $dateBefore = null, $page = '1', $archived = 'false')
    {

        $resourcePath = '/api/v11/ServiceCollection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($archived !== null) {
            $queryParams['archived'] = ObjectSerializer::toQueryValue($archived, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionIdGet
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection
     */
    public function apiV11ServiceCollectionIdGet($id, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceCollectionIdGetWithHttpInfo($id, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionIdGetWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionIdGetRequest($id, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionIdGetAsync
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdGetAsync($id, $showHeader = 'false')
    {
        return $this->apiV11ServiceCollectionIdGetAsyncWithHttpInfo($id, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdGetAsyncWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionIdGetRequest($id, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceCollectionIdGetRequest($id, $showHeader = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceCollectionIdGet'
            );
        }

        $resourcePath = '/api/v11/ServiceCollection/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionIdPut
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection
     */
    public function apiV11ServiceCollectionIdPut($id, $body = null)
    {
        list($response) = $this->apiV11ServiceCollectionIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionIdPutWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionIdPutAsync
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdPutAsync($id, $body = null)
    {
        return $this->apiV11ServiceCollectionIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionIdPutAsyncWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionIdPut'
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceCollectionIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceCollectionIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceCollection/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGet
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging
     */
    public function apiV11ServiceCollectionOrganizationGet($organizationId = null, $code = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceCollectionOrganizationGetWithHttpInfo($organizationId, $code, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGetWithHttpInfo
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionOrganizationGetWithHttpInfo($organizationId = null, $code = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging';
        $request = $this->apiV11ServiceCollectionOrganizationGetRequest($organizationId, $code, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGetAsync
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionOrganizationGetAsync($organizationId = null, $code = null, $page = '1')
    {
        return $this->apiV11ServiceCollectionOrganizationGetAsyncWithHttpInfo($organizationId, $code, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGetAsyncWithHttpInfo
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionOrganizationGetAsyncWithHttpInfo($organizationId = null, $code = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging';
        $request = $this->apiV11ServiceCollectionOrganizationGetRequest($organizationId, $code, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionOrganizationGet'
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceCollectionOrganizationGetRequest($organizationId = null, $code = null, $page = '1')
    {

        $resourcePath = '/api/v11/ServiceCollection/organization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($organizationId !== null) {
            $queryParams['organizationId'] = ObjectSerializer::toQueryValue($organizationId, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionPost
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $body The service collection data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection
     */
    public function apiV11ServiceCollectionPost($body = null)
    {
        list($response) = $this->apiV11ServiceCollectionPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionPostWithHttpInfo
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $body The service collection data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionPostWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionPostAsync
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $body The service collection data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionPostAsync($body = null)
    {
        return $this->apiV11ServiceCollectionPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionPostAsyncWithHttpInfo
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $body The service collection data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionPost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $body The service collection data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceCollectionPostRequest($body = null)
    {

        $resourcePath = '/api/v11/ServiceCollection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPut
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPut($sourceId, $body = null)
    {
        list($response) = $this->apiV11ServiceCollectionSourceIdSourceIdPutWithHttpInfo($sourceId, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPutWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionSourceIdSourceIdPutRequest($sourceId, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPutAsync
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutAsync($sourceId, $body = null)
    {
        return $this->apiV11ServiceCollectionSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionSourceIdSourceIdPutRequest($sourceId, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionSourceIdSourceIdPut'
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $body The service collection data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceCollectionSourceIdSourceIdPutRequest($sourceId, $body = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceCollectionSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceCollection/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
