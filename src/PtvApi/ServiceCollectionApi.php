<?php
/**
 * ServiceCollectionApi
 * PHP version 7.4
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * PTV Open Api version 11
 *
 * Here you can see listed all the PTV Open Api methods.
 *
 * The version of the OpenAPI document: v11
 * Generated by: https://openapi-generator.tech
 * OpenAPI Generator version: 6.6.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace Tampere\PtvV11\PtvApi;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Tampere\PtvV11\ApiException;
use Tampere\PtvV11\Configuration;
use Tampere\PtvV11\HeaderSelector;
use Tampere\PtvV11\ObjectSerializer;

/**
 * ServiceCollectionApi Class Doc Comment
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class ServiceCollectionApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'apiV11ServiceCollectionGet' => [
            'application/json',
        ],
        'apiV11ServiceCollectionIdGet' => [
            'application/json',
        ],
        'apiV11ServiceCollectionIdPut' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiV11ServiceCollectionOrganizationGet' => [
            'application/json',
        ],
        'apiV11ServiceCollectionPost' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
        'apiV11ServiceCollectionSourceIdSourceIdPut' => [
            'application/json-patch+json',
            'application/json',
            'text/json',
            'application/*+json',
        ],
    ];

/**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null,
        $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiV11ServiceCollectionGet
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionGet'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError
     */
    public function apiV11ServiceCollectionGet($date = null, $dateBefore = null, $page = 1, $archived = false, string $contentType = self::contentTypes['apiV11ServiceCollectionGet'][0])
    {
        list($response) = $this->apiV11ServiceCollectionGetWithHttpInfo($date, $dateBefore, $page, $archived, $contentType);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionGetWithHttpInfo
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionGet'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionGetWithHttpInfo($date = null, $dateBefore = null, $page = 1, $archived = false, string $contentType = self::contentTypes['apiV11ServiceCollectionGet'][0])
    {
        $request = $this->apiV11ServiceCollectionGetRequest($date, $dateBefore, $page, $archived, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionGetAsync
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionGetAsync($date = null, $dateBefore = null, $page = 1, $archived = false, string $contentType = self::contentTypes['apiV11ServiceCollectionGet'][0])
    {
        return $this->apiV11ServiceCollectionGetAsyncWithHttpInfo($date, $dateBefore, $page, $archived, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionGetAsyncWithHttpInfo
     *
     * Gets all the published service collections within PTV as a list of service collection ids and names.  Service collections created after certain date can be fetched by adding date as query string parameter.  Service collections created before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting parameter archived to true.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionGetAsyncWithHttpInfo($date = null, $dateBefore = null, $page = 1, $archived = false, string $contentType = self::contentTypes['apiV11ServiceCollectionGet'][0])
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceCollectionGetRequest($date, $dateBefore, $page, $archived, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionGet'
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  bool $archived Get archived items by setting archived to true. (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV11ServiceCollectionGetRequest($date = null, $dateBefore = null, $page = 1, $archived = false, string $contentType = self::contentTypes['apiV11ServiceCollectionGet'][0])
    {






        $resourcePath = '/api/v11/ServiceCollection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $date,
            'date', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $dateBefore,
            'dateBefore', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $archived,
            'archived', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionIdGet
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader  (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdGet'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError|\Tampere\PtvV11\PtvModel\IVmError
     */
    public function apiV11ServiceCollectionIdGet($id, $showHeader = false, string $contentType = self::contentTypes['apiV11ServiceCollectionIdGet'][0])
    {
        list($response) = $this->apiV11ServiceCollectionIdGetWithHttpInfo($id, $showHeader, $contentType);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader  (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdGet'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError|\Tampere\PtvV11\PtvModel\IVmError, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionIdGetWithHttpInfo($id, $showHeader = false, string $contentType = self::contentTypes['apiV11ServiceCollectionIdGet'][0])
    {
        $request = $this->apiV11ServiceCollectionIdGetRequest($id, $showHeader, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionIdGetAsync
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader  (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdGetAsync($id, $showHeader = false, string $contentType = self::contentTypes['apiV11ServiceCollectionIdGet'][0])
    {
        return $this->apiV11ServiceCollectionIdGetAsyncWithHttpInfo($id, $showHeader, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service collection.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader  (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdGetAsyncWithHttpInfo($id, $showHeader = false, string $contentType = self::contentTypes['apiV11ServiceCollectionIdGet'][0])
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionIdGetRequest($id, $showHeader, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader  (optional, default to false)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV11ServiceCollectionIdGetRequest($id, $showHeader = false, string $contentType = self::contentTypes['apiV11ServiceCollectionIdGet'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceCollectionIdGet'
            );
        }



        $resourcePath = '/api/v11/ServiceCollection/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $showHeader,
            'showHeader', // param base name
            'boolean', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionIdPut
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdPut'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError|\Tampere\PtvV11\PtvModel\IVmError
     */
    public function apiV11ServiceCollectionIdPut($id, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionIdPut'][0])
    {
        list($response) = $this->apiV11ServiceCollectionIdPutWithHttpInfo($id, $v11VmOpenApiServiceCollectionInBase, $contentType);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionIdPutWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdPut'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError|\Tampere\PtvV11\PtvModel\IVmError, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionIdPutWithHttpInfo($id, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionIdPut'][0])
    {
        $request = $this->apiV11ServiceCollectionIdPutRequest($id, $v11VmOpenApiServiceCollectionInBase, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionIdPutAsync
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdPutAsync($id, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionIdPut'][0])
    {
        return $this->apiV11ServiceCollectionIdPutAsyncWithHttpInfo($id, $v11VmOpenApiServiceCollectionInBase, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionIdPutAsyncWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionIdPutAsyncWithHttpInfo($id, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionIdPut'][0])
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionIdPutRequest($id, $v11VmOpenApiServiceCollectionInBase, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionIdPut'
     *
     * @param  string $id Service collection identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV11ServiceCollectionIdPutRequest($id, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionIdPut'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceCollectionIdPut'
            );
        }



        $resourcePath = '/api/v11/ServiceCollection/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v11VmOpenApiServiceCollectionInBase)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v11VmOpenApiServiceCollectionInBase));
            } else {
                $httpBody = $v11VmOpenApiServiceCollectionInBase;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGet
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionOrganizationGet'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError|\Tampere\PtvV11\PtvModel\IVmError
     */
    public function apiV11ServiceCollectionOrganizationGet($organizationId = null, $code = null, $page = 1, string $contentType = self::contentTypes['apiV11ServiceCollectionOrganizationGet'][0])
    {
        list($response) = $this->apiV11ServiceCollectionOrganizationGetWithHttpInfo($organizationId, $code, $page, $contentType);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGetWithHttpInfo
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionOrganizationGet'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError|\Tampere\PtvV11\PtvModel\IVmError, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionOrganizationGetWithHttpInfo($organizationId = null, $code = null, $page = 1, string $contentType = self::contentTypes['apiV11ServiceCollectionOrganizationGet'][0])
    {
        $request = $this->apiV11ServiceCollectionOrganizationGetRequest($organizationId, $code, $page, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGetAsync
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionOrganizationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionOrganizationGetAsync($organizationId = null, $code = null, $page = 1, string $contentType = self::contentTypes['apiV11ServiceCollectionOrganizationGet'][0])
    {
        return $this->apiV11ServiceCollectionOrganizationGetAsyncWithHttpInfo($organizationId, $code, $page, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionOrganizationGetAsyncWithHttpInfo
     *
     * Gets the published service collections within PTV related to certain organization. Either organizationId or code needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionOrganizationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionOrganizationGetAsyncWithHttpInfo($organizationId = null, $code = null, $page = 1, string $contentType = self::contentTypes['apiV11ServiceCollectionOrganizationGet'][0])
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V10VmOpenApiServiceCollectionsWithPaging';
        $request = $this->apiV11ServiceCollectionOrganizationGetRequest($organizationId, $code, $page, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionOrganizationGet'
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionOrganizationGet'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV11ServiceCollectionOrganizationGetRequest($organizationId = null, $code = null, $page = 1, string $contentType = self::contentTypes['apiV11ServiceCollectionOrganizationGet'][0])
    {





        $resourcePath = '/api/v11/ServiceCollection/organization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $organizationId,
            'organizationId', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $code,
            'code', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $page,
            'page', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionPost
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $v11VmOpenApiServiceCollectionIn The service collection data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionPost'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError
     */
    public function apiV11ServiceCollectionPost($v11VmOpenApiServiceCollectionIn = null, string $contentType = self::contentTypes['apiV11ServiceCollectionPost'][0])
    {
        list($response) = $this->apiV11ServiceCollectionPostWithHttpInfo($v11VmOpenApiServiceCollectionIn, $contentType);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionPostWithHttpInfo
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $v11VmOpenApiServiceCollectionIn The service collection data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionPost'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionPostWithHttpInfo($v11VmOpenApiServiceCollectionIn = null, string $contentType = self::contentTypes['apiV11ServiceCollectionPost'][0])
    {
        $request = $this->apiV11ServiceCollectionPostRequest($v11VmOpenApiServiceCollectionIn, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionPostAsync
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $v11VmOpenApiServiceCollectionIn The service collection data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionPostAsync($v11VmOpenApiServiceCollectionIn = null, string $contentType = self::contentTypes['apiV11ServiceCollectionPost'][0])
    {
        return $this->apiV11ServiceCollectionPostAsyncWithHttpInfo($v11VmOpenApiServiceCollectionIn, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionPostAsyncWithHttpInfo
     *
     * Creates a new service collection with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $v11VmOpenApiServiceCollectionIn The service collection data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionPostAsyncWithHttpInfo($v11VmOpenApiServiceCollectionIn = null, string $contentType = self::contentTypes['apiV11ServiceCollectionPost'][0])
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionPostRequest($v11VmOpenApiServiceCollectionIn, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionPost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionIn $v11VmOpenApiServiceCollectionIn The service collection data. (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionPost'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV11ServiceCollectionPostRequest($v11VmOpenApiServiceCollectionIn = null, string $contentType = self::contentTypes['apiV11ServiceCollectionPost'][0])
    {



        $resourcePath = '/api/v11/ServiceCollection';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v11VmOpenApiServiceCollectionIn)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v11VmOpenApiServiceCollectionIn));
            } else {
                $httpBody = $v11VmOpenApiServiceCollectionIn;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPut
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|\Tampere\PtvV11\PtvModel\IVmError|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPut($sourceId, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'][0])
    {
        list($response) = $this->apiV11ServiceCollectionSourceIdSourceIdPutWithHttpInfo($sourceId, $v11VmOpenApiServiceCollectionInBase, $contentType);
        return $response;
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPutWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'] to see the possible values for this operation
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection|\Tampere\PtvV11\PtvModel\IVmError|array<string,string[]>|\Tampere\PtvV11\PtvModel\IVmError, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutWithHttpInfo($sourceId, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'][0])
    {
        $request = $this->apiV11ServiceCollectionSourceIdSourceIdPutRequest($sourceId, $v11VmOpenApiServiceCollectionInBase, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            switch($statusCode) {
                case 200:
                    if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 404:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 400:
                    if ('array<string,string[]>' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('array<string,string[]>' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, 'array<string,string[]>', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                case 500:
                    if ('\Tampere\PtvV11\PtvModel\IVmError' === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ('\Tampere\PtvV11\PtvModel\IVmError' !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, '\Tampere\PtvV11\PtvModel\IVmError', []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
            }

            $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
            if ($returnType === '\SplFileObject') {
                $content = $response->getBody(); //stream goes to serializer
            } else {
                $content = (string) $response->getBody();
                if ($returnType !== 'string') {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'array<string,string[]>',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPutAsync
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutAsync($sourceId, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'][0])
    {
        return $this->apiV11ServiceCollectionSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $v11VmOpenApiServiceCollectionInBase, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceCollectionSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates the defined service collection with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'][0])
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollection';
        $request = $this->apiV11ServiceCollectionSourceIdSourceIdPutRequest($sourceId, $v11VmOpenApiServiceCollectionInBase, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceCollectionSourceIdSourceIdPut'
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceCollectionInBase $v11VmOpenApiServiceCollectionInBase The service collection data (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function apiV11ServiceCollectionSourceIdSourceIdPutRequest($sourceId, $v11VmOpenApiServiceCollectionInBase = null, string $contentType = self::contentTypes['apiV11ServiceCollectionSourceIdSourceIdPut'][0])
    {

        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceCollectionSourceIdSourceIdPut'
            );
        }



        $resourcePath = '/api/v11/ServiceCollection/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['text/plain', 'application/json', 'text/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($v11VmOpenApiServiceCollectionInBase)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($v11VmOpenApiServiceCollectionInBase));
            } else {
                $httpBody = $v11VmOpenApiServiceCollectionInBase;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'PUT',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
