<?php
/**
 * ServiceChannelApi
 * PHP version 5
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PTV Open Api version 11
 *
 * Here you can see listed all the PTV Open Api methods.
 *
 * OpenAPI spec version: v11
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.29
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Tampere\PtvV11\PtvApi;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Query;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Tampere\PtvV11\ApiException;
use Tampere\PtvV11\Configuration;
use Tampere\PtvV11\HeaderSelector;
use Tampere\PtvV11\ObjectSerializer;

/**
 * ServiceChannelApi Class Doc Comment
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ServiceChannelApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiV11ServiceChannelActiveGet
     *
     * Gets all service channels within PTV as a list of service channel ids and names. Also service channels with draft and modified versions are included.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Certain type of service channels can be fetched by setting query string parameter type.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  string $type Service channel type (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceChannelActiveGet($date = null, $dateBefore = null, $type = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceChannelActiveGetWithHttpInfo($date, $dateBefore, $type, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelActiveGetWithHttpInfo
     *
     * Gets all service channels within PTV as a list of service channel ids and names. Also service channels with draft and modified versions are included.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Certain type of service channels can be fetched by setting query string parameter type.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  string $type Service channel type (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelActiveGetWithHttpInfo($date = null, $dateBefore = null, $type = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelActiveGetRequest($date, $dateBefore, $type, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelActiveGetAsync
     *
     * Gets all service channels within PTV as a list of service channel ids and names. Also service channels with draft and modified versions are included.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Certain type of service channels can be fetched by setting query string parameter type.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  string $type Service channel type (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelActiveGetAsync($date = null, $dateBefore = null, $type = null, $page = '1')
    {
        return $this->apiV11ServiceChannelActiveGetAsyncWithHttpInfo($date, $dateBefore, $type, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelActiveGetAsyncWithHttpInfo
     *
     * Gets all service channels within PTV as a list of service channel ids and names. Also service channels with draft and modified versions are included.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Certain type of service channels can be fetched by setting query string parameter type.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  string $type Service channel type (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelActiveGetAsyncWithHttpInfo($date = null, $dateBefore = null, $type = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelActiveGetRequest($date, $dateBefore, $type, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelActiveGet'
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  string $type Service channel type (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelActiveGetRequest($date = null, $dateBefore = null, $type = null, $page = '1')
    {

        $resourcePath = '/api/v11/ServiceChannel/active';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($type !== null) {
            $queryParams['type'] = ObjectSerializer::toQueryValue($type, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelActiveIdGet
     *
     * Fetches all the information related to a single service channel. Also service channels with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels
     */
    public function apiV11ServiceChannelActiveIdGet($id, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceChannelActiveIdGetWithHttpInfo($id, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelActiveIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service channel. Also service channels with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelActiveIdGetWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels';
        $request = $this->apiV11ServiceChannelActiveIdGetRequest($id, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelActiveIdGetAsync
     *
     * Fetches all the information related to a single service channel. Also service channels with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelActiveIdGetAsync($id, $showHeader = 'false')
    {
        return $this->apiV11ServiceChannelActiveIdGetAsyncWithHttpInfo($id, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelActiveIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service channel. Also service channels with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelActiveIdGetAsyncWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels';
        $request = $this->apiV11ServiceChannelActiveIdGetRequest($id, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelActiveIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelActiveIdGetRequest($id, $showHeader = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelActiveIdGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/active/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelArchivedListGet
     *
     * Fetches automatically/manually archived service channels
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How channel was archived. (required)
     * @param  string $organizationId Return only channels belonging to this organization. (required)
     * @param  int $take How many channels to return. (required)
     * @param  \DateTime $minArchivingDate Return only channels archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only channels archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n channels. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceChannelBase[]
     */
    public function apiV11ServiceChannelArchivedListGet($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        list($response) = $this->apiV11ServiceChannelArchivedListGetWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelArchivedListGetWithHttpInfo
     *
     * Fetches automatically/manually archived service channels
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How channel was archived. (required)
     * @param  string $organizationId Return only channels belonging to this organization. (required)
     * @param  int $take How many channels to return. (required)
     * @param  \DateTime $minArchivingDate Return only channels archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only channels archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n channels. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceChannelBase[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelArchivedListGetWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceChannelBase[]';
        $request = $this->apiV11ServiceChannelArchivedListGetRequest($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceChannelBase[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelArchivedListGetAsync
     *
     * Fetches automatically/manually archived service channels
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How channel was archived. (required)
     * @param  string $organizationId Return only channels belonging to this organization. (required)
     * @param  int $take How many channels to return. (required)
     * @param  \DateTime $minArchivingDate Return only channels archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only channels archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n channels. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelArchivedListGetAsync($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        return $this->apiV11ServiceChannelArchivedListGetAsyncWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelArchivedListGetAsyncWithHttpInfo
     *
     * Fetches automatically/manually archived service channels
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How channel was archived. (required)
     * @param  string $organizationId Return only channels belonging to this organization. (required)
     * @param  int $take How many channels to return. (required)
     * @param  \DateTime $minArchivingDate Return only channels archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only channels archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n channels. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelArchivedListGetAsyncWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceChannelBase[]';
        $request = $this->apiV11ServiceChannelArchivedListGetRequest($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelArchivedListGet'
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How channel was archived. (required)
     * @param  string $organizationId Return only channels belonging to this organization. (required)
     * @param  int $take How many channels to return. (required)
     * @param  \DateTime $minArchivingDate Return only channels archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only channels archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n channels. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelArchivedListGetRequest($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        // verify the required parameter 'archivingType' is set
        if ($archivingType === null || (is_array($archivingType) && count($archivingType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $archivingType when calling apiV11ServiceChannelArchivedListGet'
            );
        }
        // verify the required parameter 'organizationId' is set
        if ($organizationId === null || (is_array($organizationId) && count($organizationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organizationId when calling apiV11ServiceChannelArchivedListGet'
            );
        }
        // verify the required parameter 'take' is set
        if ($take === null || (is_array($take) && count($take) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $take when calling apiV11ServiceChannelArchivedListGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/archived/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($archivingType !== null) {
            $queryParams['ArchivingType'] = ObjectSerializer::toQueryValue($archivingType, null);
        }
        // query params
        if ($organizationId !== null) {
            $queryParams['OrganizationId'] = ObjectSerializer::toQueryValue($organizationId, 'uuid');
        }
        // query params
        if ($minArchivingDate !== null) {
            $queryParams['MinArchivingDate'] = ObjectSerializer::toQueryValue($minArchivingDate, 'date-time');
        }
        // query params
        if ($maxArchivingDate !== null) {
            $queryParams['MaxArchivingDate'] = ObjectSerializer::toQueryValue($maxArchivingDate, 'date-time');
        }
        // query params
        if ($skip !== null) {
            $queryParams['Skip'] = ObjectSerializer::toQueryValue($skip, 'int32');
        }
        // query params
        if ($take !== null) {
            $queryParams['Take'] = ObjectSerializer::toQueryValue($take, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelAreaAreaCodeCodeGet
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceChannelAreaAreaCodeCodeGet($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceChannelAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelAreaAreaCodeCodeGetWithHttpInfo
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelAreaAreaCodeCodeGetAsync
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelAreaAreaCodeCodeGetAsync($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceChannelAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelAreaAreaCodeCodeGetAsyncWithHttpInfo
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelAreaAreaCodeCodeGet'
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'area' is set
        if ($area === null || (is_array($area) && count($area) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $area when calling apiV11ServiceChannelAreaAreaCodeCodeGet'
            );
        }
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling apiV11ServiceChannelAreaAreaCodeCodeGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/area/{area}/code/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($includeWholeCountry !== null) {
            $queryParams['includeWholeCountry'] = ObjectSerializer::toQueryValue($includeWholeCountry, null);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($area !== null) {
            $resourcePath = str_replace(
                '{' . 'area' . '}',
                ObjectSerializer::toPathValue($area),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelEChannelIdPut
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $id electronic channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel
     */
    public function apiV11ServiceChannelEChannelIdPut($id, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelEChannelIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelEChannelIdPutWithHttpInfo
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $id electronic channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelEChannelIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel';
        $request = $this->apiV11ServiceChannelEChannelIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelEChannelIdPutAsync
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $id electronic channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelEChannelIdPutAsync($id, $body = null)
    {
        return $this->apiV11ServiceChannelEChannelIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelEChannelIdPutAsyncWithHttpInfo
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $id electronic channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelEChannelIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel';
        $request = $this->apiV11ServiceChannelEChannelIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelEChannelIdPut'
     *
     * @param  string $id electronic channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelEChannelIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelEChannelIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/EChannel/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelEChannelPost
     *
     * Creates a new electronic channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelIn $body The electronic channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel
     */
    public function apiV11ServiceChannelEChannelPost($body = null)
    {
        list($response) = $this->apiV11ServiceChannelEChannelPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelEChannelPostWithHttpInfo
     *
     * Creates a new electronic channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelIn $body The electronic channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelEChannelPostWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel';
        $request = $this->apiV11ServiceChannelEChannelPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelEChannelPostAsync
     *
     * Creates a new electronic channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelIn $body The electronic channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelEChannelPostAsync($body = null)
    {
        return $this->apiV11ServiceChannelEChannelPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelEChannelPostAsyncWithHttpInfo
     *
     * Creates a new electronic channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelIn $body The electronic channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelEChannelPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel';
        $request = $this->apiV11ServiceChannelEChannelPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelEChannelPost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelIn $body The electronic channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelEChannelPostRequest($body = null)
    {

        $resourcePath = '/api/v11/ServiceChannel/EChannel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelEChannelSourceIdSourceIdPut
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $sourceId electronic channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel
     */
    public function apiV11ServiceChannelEChannelSourceIdSourceIdPut($sourceId, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelEChannelSourceIdSourceIdPutWithHttpInfo($sourceId, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelEChannelSourceIdSourceIdPutWithHttpInfo
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $sourceId electronic channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelEChannelSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel';
        $request = $this->apiV11ServiceChannelEChannelSourceIdSourceIdPutRequest($sourceId, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelEChannelSourceIdSourceIdPutAsync
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $sourceId electronic channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelEChannelSourceIdSourceIdPutAsync($sourceId, $body = null)
    {
        return $this->apiV11ServiceChannelEChannelSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelEChannelSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates electronic channel with the data provided as input.
     *
     * @param  string $sourceId electronic channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelEChannelSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannel';
        $request = $this->apiV11ServiceChannelEChannelSourceIdSourceIdPutRequest($sourceId, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelEChannelSourceIdSourceIdPut'
     *
     * @param  string $sourceId electronic channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiElectronicChannelInBase $body electronic channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelEChannelSourceIdSourceIdPutRequest($sourceId, $body = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceChannelEChannelSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/EChannel/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelGet
     *
     * Gets all published service channels within PTV as a list of service channel ids and names.  Service channels created/modified after certain date can be fetched by adding date as query string parameter  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  string $organizationId You can restrict the result set by setting organization guid. (optional)
     * @param  string $code You can restrict the result set by setting organization business code. (optional)
     * @param  string $oid You can restrict the result set by setting organization oid. (optional)
     * @param  bool $isVisibleForAll When set to true only service channels marked as isVisibleForAll are returned. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceChannelGet($date = null, $dateBefore = null, $organizationId = null, $code = null, $oid = null, $isVisibleForAll = 'false', $page = '1', $status = 'Published')
    {
        list($response) = $this->apiV11ServiceChannelGetWithHttpInfo($date, $dateBefore, $organizationId, $code, $oid, $isVisibleForAll, $page, $status);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelGetWithHttpInfo
     *
     * Gets all published service channels within PTV as a list of service channel ids and names.  Service channels created/modified after certain date can be fetched by adding date as query string parameter  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  string $organizationId You can restrict the result set by setting organization guid. (optional)
     * @param  string $code You can restrict the result set by setting organization business code. (optional)
     * @param  string $oid You can restrict the result set by setting organization oid. (optional)
     * @param  bool $isVisibleForAll When set to true only service channels marked as isVisibleForAll are returned. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelGetWithHttpInfo($date = null, $dateBefore = null, $organizationId = null, $code = null, $oid = null, $isVisibleForAll = 'false', $page = '1', $status = 'Published')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelGetRequest($date, $dateBefore, $organizationId, $code, $oid, $isVisibleForAll, $page, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelGetAsync
     *
     * Gets all published service channels within PTV as a list of service channel ids and names.  Service channels created/modified after certain date can be fetched by adding date as query string parameter  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  string $organizationId You can restrict the result set by setting organization guid. (optional)
     * @param  string $code You can restrict the result set by setting organization business code. (optional)
     * @param  string $oid You can restrict the result set by setting organization oid. (optional)
     * @param  bool $isVisibleForAll When set to true only service channels marked as isVisibleForAll are returned. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelGetAsync($date = null, $dateBefore = null, $organizationId = null, $code = null, $oid = null, $isVisibleForAll = 'false', $page = '1', $status = 'Published')
    {
        return $this->apiV11ServiceChannelGetAsyncWithHttpInfo($date, $dateBefore, $organizationId, $code, $oid, $isVisibleForAll, $page, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelGetAsyncWithHttpInfo
     *
     * Gets all published service channels within PTV as a list of service channel ids and names.  Service channels created/modified after certain date can be fetched by adding date as query string parameter  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  string $organizationId You can restrict the result set by setting organization guid. (optional)
     * @param  string $code You can restrict the result set by setting organization business code. (optional)
     * @param  string $oid You can restrict the result set by setting organization oid. (optional)
     * @param  bool $isVisibleForAll When set to true only service channels marked as isVisibleForAll are returned. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelGetAsyncWithHttpInfo($date = null, $dateBefore = null, $organizationId = null, $code = null, $oid = null, $isVisibleForAll = 'false', $page = '1', $status = 'Published')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelGetRequest($date, $dateBefore, $organizationId, $code, $oid, $isVisibleForAll, $page, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelGet'
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC) (optional)
     * @param  string $organizationId You can restrict the result set by setting organization guid. (optional)
     * @param  string $code You can restrict the result set by setting organization business code. (optional)
     * @param  string $oid You can restrict the result set by setting organization oid. (optional)
     * @param  bool $isVisibleForAll When set to true only service channels marked as isVisibleForAll are returned. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelGetRequest($date = null, $dateBefore = null, $organizationId = null, $code = null, $oid = null, $isVisibleForAll = 'false', $page = '1', $status = 'Published')
    {

        $resourcePath = '/api/v11/ServiceChannel';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($organizationId !== null) {
            $queryParams['organizationId'] = ObjectSerializer::toQueryValue($organizationId, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($oid !== null) {
            $queryParams['oid'] = ObjectSerializer::toQueryValue($oid, null);
        }
        // query params
        if ($isVisibleForAll !== null) {
            $queryParams['isVisibleForAll'] = ObjectSerializer::toQueryValue($isVisibleForAll, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelIdGet
     *
     * Fetches all the information related to a single service channel.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels
     */
    public function apiV11ServiceChannelIdGet($id, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceChannelIdGetWithHttpInfo($id, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service channel.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelIdGetWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels';
        $request = $this->apiV11ServiceChannelIdGetRequest($id, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelIdGetAsync
     *
     * Fetches all the information related to a single service channel.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelIdGetAsync($id, $showHeader = 'false')
    {
        return $this->apiV11ServiceChannelIdGetAsyncWithHttpInfo($id, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service channel.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelIdGetAsyncWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels';
        $request = $this->apiV11ServiceChannelIdGetRequest($id, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelIdGetRequest($id, $showHeader = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelIdGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelListAreaAreaCodeCodeGet
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging
     */
    public function apiV11ServiceChannelListAreaAreaCodeCodeGet($area, $code, $includeWholeCountry = null, $page = '1', $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceChannelListAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry, $page, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelListAreaAreaCodeCodeGetWithHttpInfo
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelListAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry = null, $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging';
        $request = $this->apiV11ServiceChannelListAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $page, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelListAreaAreaCodeCodeGetAsync
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelListAreaAreaCodeCodeGetAsync($area, $code, $includeWholeCountry = null, $page = '1', $showHeader = 'false')
    {
        return $this->apiV11ServiceChannelListAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry, $page, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelListAreaAreaCodeCodeGetAsyncWithHttpInfo
     *
     * Gets a list of service channels related to defined area and code.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelListAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry = null, $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging';
        $request = $this->apiV11ServiceChannelListAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $page, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelListAreaAreaCodeCodeGet'
     *
     * @param  string $area The area type (required)
     * @param  string $code The area code (required)
     * @param  bool $includeWholeCountry Indicates if service channels marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelListAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry = null, $page = '1', $showHeader = 'false')
    {
        // verify the required parameter 'area' is set
        if ($area === null || (is_array($area) && count($area) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $area when calling apiV11ServiceChannelListAreaAreaCodeCodeGet'
            );
        }
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling apiV11ServiceChannelListAreaAreaCodeCodeGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/list/area/{area}/code/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($includeWholeCountry !== null) {
            $queryParams['includeWholeCountry'] = ObjectSerializer::toQueryValue($includeWholeCountry, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($area !== null) {
            $resourcePath = str_replace(
                '{' . 'area' . '}',
                ObjectSerializer::toPathValue($area),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelListGet
     *
     * Fetches all the information related to requested service channels.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels[]
     */
    public function apiV11ServiceChannelListGet($guids = null, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceChannelListGetWithHttpInfo($guids, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelListGetWithHttpInfo
     *
     * Fetches all the information related to requested service channels.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelListGetWithHttpInfo($guids = null, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels[]';
        $request = $this->apiV11ServiceChannelListGetRequest($guids, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelListGetAsync
     *
     * Fetches all the information related to requested service channels.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelListGetAsync($guids = null, $showHeader = 'false')
    {
        return $this->apiV11ServiceChannelListGetAsyncWithHttpInfo($guids, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelListGetAsyncWithHttpInfo
     *
     * Fetches all the information related to requested service channels.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelListGetAsyncWithHttpInfo($guids = null, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannels[]';
        $request = $this->apiV11ServiceChannelListGetRequest($guids, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelListGet'
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelListGetRequest($guids = null, $showHeader = 'false')
    {

        $resourcePath = '/api/v11/ServiceChannel/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($guids !== null) {
            $queryParams['guids'] = ObjectSerializer::toQueryValue($guids, null);
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelListOrganizationGet
     *
     * Fetches all the information of service channels related to certain organization. Either organizationId, code or oid needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging
     */
    public function apiV11ServiceChannelListOrganizationGet($organizationId = null, $code = null, $oid = null, $page = '1', $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceChannelListOrganizationGetWithHttpInfo($organizationId, $code, $oid, $page, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelListOrganizationGetWithHttpInfo
     *
     * Fetches all the information of service channels related to certain organization. Either organizationId, code or oid needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelListOrganizationGetWithHttpInfo($organizationId = null, $code = null, $oid = null, $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging';
        $request = $this->apiV11ServiceChannelListOrganizationGetRequest($organizationId, $code, $oid, $page, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelListOrganizationGetAsync
     *
     * Fetches all the information of service channels related to certain organization. Either organizationId, code or oid needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelListOrganizationGetAsync($organizationId = null, $code = null, $oid = null, $page = '1', $showHeader = 'false')
    {
        return $this->apiV11ServiceChannelListOrganizationGetAsyncWithHttpInfo($organizationId, $code, $oid, $page, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelListOrganizationGetAsyncWithHttpInfo
     *
     * Fetches all the information of service channels related to certain organization. Either organizationId, code or oid needs to be added as a parameter.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelListOrganizationGetAsyncWithHttpInfo($organizationId = null, $code = null, $oid = null, $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceChannelsWithPaging';
        $request = $this->apiV11ServiceChannelListOrganizationGetRequest($organizationId, $code, $oid, $page, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelListOrganizationGet'
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelListOrganizationGetRequest($organizationId = null, $code = null, $oid = null, $page = '1', $showHeader = 'false')
    {

        $resourcePath = '/api/v11/ServiceChannel/list/organization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($organizationId !== null) {
            $queryParams['organizationId'] = ObjectSerializer::toQueryValue($organizationId, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($oid !== null) {
            $queryParams['oid'] = ObjectSerializer::toQueryValue($oid, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdGet
     *
     * Gets a list of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdGet($organizationId, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceChannelOrganizationOrganizationIdGetWithHttpInfo($organizationId, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdGetWithHttpInfo
     *
     * Gets a list of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdGetWithHttpInfo($organizationId, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelOrganizationOrganizationIdGetRequest($organizationId, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdGetAsync
     *
     * Gets a list of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdGetAsync($organizationId, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceChannelOrganizationOrganizationIdGetAsyncWithHttpInfo($organizationId, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdGetAsyncWithHttpInfo
     *
     * Gets a list of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdGetAsyncWithHttpInfo($organizationId, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelOrganizationOrganizationIdGetRequest($organizationId, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelOrganizationOrganizationIdGet'
     *
     * @param  string $organizationId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelOrganizationOrganizationIdGetRequest($organizationId, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'organizationId' is set
        if ($organizationId === null || (is_array($organizationId) && count($organizationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organizationId when calling apiV11ServiceChannelOrganizationOrganizationIdGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/organization/{organizationId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($organizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organizationId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGet
     *
     * Gets a list of certain type of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGet($organizationId, $type, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetWithHttpInfo($organizationId, $type, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetWithHttpInfo
     *
     * Gets a list of certain type of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetWithHttpInfo($organizationId, $type, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetRequest($organizationId, $type, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetAsync
     *
     * Gets a list of certain type of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetAsync($organizationId, $type, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetAsyncWithHttpInfo($organizationId, $type, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetAsyncWithHttpInfo
     *
     * Gets a list of certain type of published service channels for defined organization.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $organizationId Guid (required)
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetAsyncWithHttpInfo($organizationId, $type, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetRequest($organizationId, $type, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGet'
     *
     * @param  string $organizationId Guid (required)
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGetRequest($organizationId, $type, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'organizationId' is set
        if ($organizationId === null || (is_array($organizationId) && count($organizationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organizationId when calling apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGet'
            );
        }
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling apiV11ServiceChannelOrganizationOrganizationIdTypeTypeGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/organization/{organizationId}/type/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($organizationId !== null) {
            $resourcePath = str_replace(
                '{' . 'organizationId' . '}',
                ObjectSerializer::toPathValue($organizationId),
                $resourcePath
            );
        }
        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelPhoneIdPut
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $id phone channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel
     */
    public function apiV11ServiceChannelPhoneIdPut($id, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelPhoneIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelPhoneIdPutWithHttpInfo
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $id phone channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelPhoneIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel';
        $request = $this->apiV11ServiceChannelPhoneIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelPhoneIdPutAsync
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $id phone channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPhoneIdPutAsync($id, $body = null)
    {
        return $this->apiV11ServiceChannelPhoneIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelPhoneIdPutAsyncWithHttpInfo
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $id phone channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPhoneIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel';
        $request = $this->apiV11ServiceChannelPhoneIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelPhoneIdPut'
     *
     * @param  string $id phone channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelPhoneIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelPhoneIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/Phone/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelPhonePost
     *
     * Creates a new phone channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelIn $body The phone channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel
     */
    public function apiV11ServiceChannelPhonePost($body = null)
    {
        list($response) = $this->apiV11ServiceChannelPhonePostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelPhonePostWithHttpInfo
     *
     * Creates a new phone channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelIn $body The phone channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelPhonePostWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel';
        $request = $this->apiV11ServiceChannelPhonePostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelPhonePostAsync
     *
     * Creates a new phone channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelIn $body The phone channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPhonePostAsync($body = null)
    {
        return $this->apiV11ServiceChannelPhonePostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelPhonePostAsyncWithHttpInfo
     *
     * Creates a new phone channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelIn $body The phone channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPhonePostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel';
        $request = $this->apiV11ServiceChannelPhonePostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelPhonePost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelIn $body The phone channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelPhonePostRequest($body = null)
    {

        $resourcePath = '/api/v11/ServiceChannel/Phone';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelPhoneSourceIdSourceIdPut
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $sourceId phone channel external id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel
     */
    public function apiV11ServiceChannelPhoneSourceIdSourceIdPut($sourceId, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelPhoneSourceIdSourceIdPutWithHttpInfo($sourceId, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelPhoneSourceIdSourceIdPutWithHttpInfo
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $sourceId phone channel external id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelPhoneSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel';
        $request = $this->apiV11ServiceChannelPhoneSourceIdSourceIdPutRequest($sourceId, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelPhoneSourceIdSourceIdPutAsync
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $sourceId phone channel external id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPhoneSourceIdSourceIdPutAsync($sourceId, $body = null)
    {
        return $this->apiV11ServiceChannelPhoneSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelPhoneSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates phone channel with the data provided as input.
     *
     * @param  string $sourceId phone channel external id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPhoneSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannel';
        $request = $this->apiV11ServiceChannelPhoneSourceIdSourceIdPutRequest($sourceId, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelPhoneSourceIdSourceIdPut'
     *
     * @param  string $sourceId phone channel external id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiPhoneChannelInBase $body phone channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelPhoneSourceIdSourceIdPutRequest($sourceId, $body = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceChannelPhoneSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/Phone/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormIdPut
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $id printable form channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel
     */
    public function apiV11ServiceChannelPrintableFormIdPut($id, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelPrintableFormIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormIdPutWithHttpInfo
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $id printable form channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelPrintableFormIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel';
        $request = $this->apiV11ServiceChannelPrintableFormIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormIdPutAsync
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $id printable form channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPrintableFormIdPutAsync($id, $body = null)
    {
        return $this->apiV11ServiceChannelPrintableFormIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormIdPutAsyncWithHttpInfo
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $id printable form channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPrintableFormIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel';
        $request = $this->apiV11ServiceChannelPrintableFormIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelPrintableFormIdPut'
     *
     * @param  string $id printable form channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelPrintableFormIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelPrintableFormIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/PrintableForm/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormPost
     *
     * Creates a new printable form channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelIn $body The printable form channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel
     */
    public function apiV11ServiceChannelPrintableFormPost($body = null)
    {
        list($response) = $this->apiV11ServiceChannelPrintableFormPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormPostWithHttpInfo
     *
     * Creates a new printable form channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelIn $body The printable form channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelPrintableFormPostWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel';
        $request = $this->apiV11ServiceChannelPrintableFormPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormPostAsync
     *
     * Creates a new printable form channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelIn $body The printable form channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPrintableFormPostAsync($body = null)
    {
        return $this->apiV11ServiceChannelPrintableFormPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormPostAsyncWithHttpInfo
     *
     * Creates a new printable form channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelIn $body The printable form channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPrintableFormPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel';
        $request = $this->apiV11ServiceChannelPrintableFormPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelPrintableFormPost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelIn $body The printable form channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelPrintableFormPostRequest($body = null)
    {

        $resourcePath = '/api/v11/ServiceChannel/PrintableForm';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormSourceIdSourceIdPut
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $sourceId printable form channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel
     */
    public function apiV11ServiceChannelPrintableFormSourceIdSourceIdPut($sourceId, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelPrintableFormSourceIdSourceIdPutWithHttpInfo($sourceId, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormSourceIdSourceIdPutWithHttpInfo
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $sourceId printable form channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelPrintableFormSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel';
        $request = $this->apiV11ServiceChannelPrintableFormSourceIdSourceIdPutRequest($sourceId, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormSourceIdSourceIdPutAsync
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $sourceId printable form channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPrintableFormSourceIdSourceIdPutAsync($sourceId, $body = null)
    {
        return $this->apiV11ServiceChannelPrintableFormSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelPrintableFormSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates printable form channel with the data provided as input.
     *
     * @param  string $sourceId printable form channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelPrintableFormSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiPrintableFormChannel';
        $request = $this->apiV11ServiceChannelPrintableFormSourceIdSourceIdPutRequest($sourceId, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelPrintableFormSourceIdSourceIdPut'
     *
     * @param  string $sourceId printable form channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiPrintableFormChannelInBase $body printable form channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelPrintableFormSourceIdSourceIdPutRequest($sourceId, $body = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceChannelPrintableFormSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/PrintableForm/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationIdPut
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $id service location channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel
     */
    public function apiV11ServiceChannelServiceLocationIdPut($id, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelServiceLocationIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationIdPutWithHttpInfo
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $id service location channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelServiceLocationIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel';
        $request = $this->apiV11ServiceChannelServiceLocationIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationIdPutAsync
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $id service location channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelServiceLocationIdPutAsync($id, $body = null)
    {
        return $this->apiV11ServiceChannelServiceLocationIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationIdPutAsyncWithHttpInfo
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $id service location channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelServiceLocationIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel';
        $request = $this->apiV11ServiceChannelServiceLocationIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelServiceLocationIdPut'
     *
     * @param  string $id service location channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelServiceLocationIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelServiceLocationIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/ServiceLocation/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationPost
     *
     * Creates a new service location channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelIn $body The service location channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel
     */
    public function apiV11ServiceChannelServiceLocationPost($body = null)
    {
        list($response) = $this->apiV11ServiceChannelServiceLocationPostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationPostWithHttpInfo
     *
     * Creates a new service location channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelIn $body The service location channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelServiceLocationPostWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel';
        $request = $this->apiV11ServiceChannelServiceLocationPostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationPostAsync
     *
     * Creates a new service location channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelIn $body The service location channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelServiceLocationPostAsync($body = null)
    {
        return $this->apiV11ServiceChannelServiceLocationPostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationPostAsyncWithHttpInfo
     *
     * Creates a new service location channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelIn $body The service location channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelServiceLocationPostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel';
        $request = $this->apiV11ServiceChannelServiceLocationPostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelServiceLocationPost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelIn $body The service location channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelServiceLocationPostRequest($body = null)
    {

        $resourcePath = '/api/v11/ServiceChannel/ServiceLocation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationSourceIdSourceIdPut
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $sourceId service location channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel
     */
    public function apiV11ServiceChannelServiceLocationSourceIdSourceIdPut($sourceId, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelServiceLocationSourceIdSourceIdPutWithHttpInfo($sourceId, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationSourceIdSourceIdPutWithHttpInfo
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $sourceId service location channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelServiceLocationSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel';
        $request = $this->apiV11ServiceChannelServiceLocationSourceIdSourceIdPutRequest($sourceId, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationSourceIdSourceIdPutAsync
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $sourceId service location channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelServiceLocationSourceIdSourceIdPutAsync($sourceId, $body = null)
    {
        return $this->apiV11ServiceChannelServiceLocationSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelServiceLocationSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates service location channel with the data provided as input.
     *
     * @param  string $sourceId service location channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelServiceLocationSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannel';
        $request = $this->apiV11ServiceChannelServiceLocationSourceIdSourceIdPutRequest($sourceId, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelServiceLocationSourceIdSourceIdPut'
     *
     * @param  string $sourceId service location channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V11VmOpenApiServiceLocationChannelInBase $body service location channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelServiceLocationSourceIdSourceIdPutRequest($sourceId, $body = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceChannelServiceLocationSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/ServiceLocation/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelTypeTypeGet
     *
     * Gets a list of certain type of published service channels.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceChannelTypeTypeGet($type, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceChannelTypeTypeGetWithHttpInfo($type, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelTypeTypeGetWithHttpInfo
     *
     * Gets a list of certain type of published service channels.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelTypeTypeGetWithHttpInfo($type, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelTypeTypeGetRequest($type, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelTypeTypeGetAsync
     *
     * Gets a list of certain type of published service channels.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelTypeTypeGetAsync($type, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceChannelTypeTypeGetAsyncWithHttpInfo($type, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelTypeTypeGetAsyncWithHttpInfo
     *
     * Gets a list of certain type of published service channels.  Service channels created/modified after certain date can be fetched by adding date as query string parameter.  Service channels created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelTypeTypeGetAsyncWithHttpInfo($type, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceChannelTypeTypeGetRequest($type, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelTypeTypeGet'
     *
     * @param  string $type Service channel type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelTypeTypeGetRequest($type, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling apiV11ServiceChannelTypeTypeGet'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/type/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelWebPageIdPut
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $id web page channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel
     */
    public function apiV11ServiceChannelWebPageIdPut($id, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelWebPageIdPutWithHttpInfo($id, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelWebPageIdPutWithHttpInfo
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $id web page channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelWebPageIdPutWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel';
        $request = $this->apiV11ServiceChannelWebPageIdPutRequest($id, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelWebPageIdPutAsync
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $id web page channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelWebPageIdPutAsync($id, $body = null)
    {
        return $this->apiV11ServiceChannelWebPageIdPutAsyncWithHttpInfo($id, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelWebPageIdPutAsyncWithHttpInfo
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $id web page channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelWebPageIdPutAsyncWithHttpInfo($id, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel';
        $request = $this->apiV11ServiceChannelWebPageIdPutRequest($id, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelWebPageIdPut'
     *
     * @param  string $id web page channel id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelWebPageIdPutRequest($id, $body = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceChannelWebPageIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/WebPage/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelWebPagePost
     *
     * Creates a new web page channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelIn $body The web page channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel
     */
    public function apiV11ServiceChannelWebPagePost($body = null)
    {
        list($response) = $this->apiV11ServiceChannelWebPagePostWithHttpInfo($body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelWebPagePostWithHttpInfo
     *
     * Creates a new web page channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelIn $body The web page channel data. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelWebPagePostWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel';
        $request = $this->apiV11ServiceChannelWebPagePostRequest($body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelWebPagePostAsync
     *
     * Creates a new web page channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelIn $body The web page channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelWebPagePostAsync($body = null)
    {
        return $this->apiV11ServiceChannelWebPagePostAsyncWithHttpInfo($body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelWebPagePostAsyncWithHttpInfo
     *
     * Creates a new web page channel with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelIn $body The web page channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelWebPagePostAsyncWithHttpInfo($body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel';
        $request = $this->apiV11ServiceChannelWebPagePostRequest($body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelWebPagePost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelIn $body The web page channel data. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelWebPagePostRequest($body = null)
    {

        $resourcePath = '/api/v11/ServiceChannel/WebPage';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceChannelWebPageSourceIdSourceIdPut
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $sourceId web page channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel
     */
    public function apiV11ServiceChannelWebPageSourceIdSourceIdPut($sourceId, $body = null)
    {
        list($response) = $this->apiV11ServiceChannelWebPageSourceIdSourceIdPutWithHttpInfo($sourceId, $body);
        return $response;
    }

    /**
     * Operation apiV11ServiceChannelWebPageSourceIdSourceIdPutWithHttpInfo
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $sourceId web page channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceChannelWebPageSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel';
        $request = $this->apiV11ServiceChannelWebPageSourceIdSourceIdPutRequest($sourceId, $body);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceChannelWebPageSourceIdSourceIdPutAsync
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $sourceId web page channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelWebPageSourceIdSourceIdPutAsync($sourceId, $body = null)
    {
        return $this->apiV11ServiceChannelWebPageSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceChannelWebPageSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates webpage channel with the data provided as input.
     *
     * @param  string $sourceId web page channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceChannelWebPageSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiWebPageChannel';
        $request = $this->apiV11ServiceChannelWebPageSourceIdSourceIdPutRequest($sourceId, $body);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceChannelWebPageSourceIdSourceIdPut'
     *
     * @param  string $sourceId web page channel external source id (required)
     * @param  \Tampere\PtvV11\PtvModel\V10VmOpenApiWebPageChannelInBase $body web page channel data (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceChannelWebPageSourceIdSourceIdPutRequest($sourceId, $body = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceChannelWebPageSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/ServiceChannel/WebPage/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;


        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = Query::build($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = Query::build($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
