<?php
/**
 * ServiceApi
 * PHP version 5
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * PTV Open Api version 11
 *
 * Here you can see listed all the PTV Open Api methods.
 *
 * OpenAPI spec version: v11
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 3.0.29
 */
/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Tampere\PtvV11\PtvApi;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Tampere\PtvV11\ApiException;
use Tampere\PtvV11\Configuration;
use Tampere\PtvV11\HeaderSelector;
use Tampere\PtvV11\ObjectSerializer;

/**
 * ServiceApi Class Doc Comment
 *
 * @category Class
 * @package  Tampere\PtvV11
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ServiceApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     */
    public function __construct(
        ClientInterface $client = null,
        Configuration $config = null,
        HeaderSelector $selector = null
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: new Configuration();
        $this->headerSelector = $selector ?: new HeaderSelector();
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation apiV11ServiceActiveGet
     *
     * Gets all services within PTV as a list of service ids and names. Also services with draft and modified versions are included.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceActiveGet($date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceActiveGetWithHttpInfo($date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceActiveGetWithHttpInfo
     *
     * Gets all services within PTV as a list of service ids and names. Also services with draft and modified versions are included.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceActiveGetWithHttpInfo($date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceActiveGetRequest($date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceActiveGetAsync
     *
     * Gets all services within PTV as a list of service ids and names. Also services with draft and modified versions are included.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceActiveGetAsync($date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceActiveGetAsyncWithHttpInfo($date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceActiveGetAsyncWithHttpInfo
     *
     * Gets all services within PTV as a list of service ids and names. Also services with draft and modified versions are included.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  NOTE! This is a restricted endpoint.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceActiveGetAsyncWithHttpInfo($date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceActiveGetRequest($date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceActiveGet'
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceActiveGetRequest($date = null, $dateBefore = null, $page = '1')
    {

        $resourcePath = '/api/v11/Service/active';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceActiveIdGet
     *
     * Fetches all the information related to a single service. Also services with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService
     */
    public function apiV11ServiceActiveIdGet($id, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceActiveIdGetWithHttpInfo($id, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceActiveIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service. Also services with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceActiveIdGetWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceActiveIdGetRequest($id, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceActiveIdGetAsync
     *
     * Fetches all the information related to a single service. Also services with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceActiveIdGetAsync($id, $showHeader = 'false')
    {
        return $this->apiV11ServiceActiveIdGetAsyncWithHttpInfo($id, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceActiveIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service. Also services with only draft or modified versions are returned.  NOTE! This is a restricted endpoint.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceActiveIdGetAsyncWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceActiveIdGetRequest($id, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceActiveIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceActiveIdGetRequest($id, $showHeader = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceActiveIdGet'
            );
        }

        $resourcePath = '/api/v11/Service/active/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceArchivedListGet
     *
     * Fetches automatically/manually archived services
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How service was archived. (required)
     * @param  string $organizationId Return only services belonging to this organization. (required)
     * @param  int $take How many services to return. (required)
     * @param  \DateTime $minArchivingDate Return only services archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only services archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n services. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceBase[]
     */
    public function apiV11ServiceArchivedListGet($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        list($response) = $this->apiV11ServiceArchivedListGetWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip);
        return $response;
    }

    /**
     * Operation apiV11ServiceArchivedListGetWithHttpInfo
     *
     * Fetches automatically/manually archived services
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How service was archived. (required)
     * @param  string $organizationId Return only services belonging to this organization. (required)
     * @param  int $take How many services to return. (required)
     * @param  \DateTime $minArchivingDate Return only services archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only services archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n services. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceBase[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceArchivedListGetWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceBase[]';
        $request = $this->apiV11ServiceArchivedListGetRequest($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceBase[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceArchivedListGetAsync
     *
     * Fetches automatically/manually archived services
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How service was archived. (required)
     * @param  string $organizationId Return only services belonging to this organization. (required)
     * @param  int $take How many services to return. (required)
     * @param  \DateTime $minArchivingDate Return only services archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only services archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n services. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceArchivedListGetAsync($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        return $this->apiV11ServiceArchivedListGetAsyncWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceArchivedListGetAsyncWithHttpInfo
     *
     * Fetches automatically/manually archived services
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How service was archived. (required)
     * @param  string $organizationId Return only services belonging to this organization. (required)
     * @param  int $take How many services to return. (required)
     * @param  \DateTime $minArchivingDate Return only services archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only services archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n services. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceArchivedListGetAsyncWithHttpInfo($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\VmOpenApiArchivedServiceBase[]';
        $request = $this->apiV11ServiceArchivedListGetRequest($archivingType, $organizationId, $take, $minArchivingDate, $maxArchivingDate, $skip);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceArchivedListGet'
     *
     * @param  \Tampere\PtvV11\PtvModel\ArchivingType $archivingType How service was archived. (required)
     * @param  string $organizationId Return only services belonging to this organization. (required)
     * @param  int $take How many services to return. (required)
     * @param  \DateTime $minArchivingDate Return only services archived after this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  \DateTime $maxArchivingDate Return only services archived before this time.  ISO 8601 format (e.g. 2020-10-26T05:24:11+00:00). (optional)
     * @param  int $skip Skip the first n services. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceArchivedListGetRequest($archivingType, $organizationId, $take, $minArchivingDate = null, $maxArchivingDate = null, $skip = null)
    {
        // verify the required parameter 'archivingType' is set
        if ($archivingType === null || (is_array($archivingType) && count($archivingType) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $archivingType when calling apiV11ServiceArchivedListGet'
            );
        }
        // verify the required parameter 'organizationId' is set
        if ($organizationId === null || (is_array($organizationId) && count($organizationId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $organizationId when calling apiV11ServiceArchivedListGet'
            );
        }
        // verify the required parameter 'take' is set
        if ($take === null || (is_array($take) && count($take) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $take when calling apiV11ServiceArchivedListGet'
            );
        }

        $resourcePath = '/api/v11/Service/archived/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($archivingType !== null) {
            $queryParams['ArchivingType'] = ObjectSerializer::toQueryValue($archivingType, null);
        }
        // query params
        if ($organizationId !== null) {
            $queryParams['OrganizationId'] = ObjectSerializer::toQueryValue($organizationId, 'uuid');
        }
        // query params
        if ($minArchivingDate !== null) {
            $queryParams['MinArchivingDate'] = ObjectSerializer::toQueryValue($minArchivingDate, 'date-time');
        }
        // query params
        if ($maxArchivingDate !== null) {
            $queryParams['MaxArchivingDate'] = ObjectSerializer::toQueryValue($maxArchivingDate, 'date-time');
        }
        // query params
        if ($skip !== null) {
            $queryParams['Skip'] = ObjectSerializer::toQueryValue($skip, 'int32');
        }
        // query params
        if ($take !== null) {
            $queryParams['Take'] = ObjectSerializer::toQueryValue($take, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceAreaAreaCodeCodeGet
     *
     * Gets a list of published services related to defined area and code.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The code related to area (required)
     * @param  bool $includeWholeCountry Indicates if services marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceAreaAreaCodeCodeGet($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceAreaAreaCodeCodeGetWithHttpInfo
     *
     * Gets a list of published services related to defined area and code.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The code related to area (required)
     * @param  bool $includeWholeCountry Indicates if services marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceAreaAreaCodeCodeGetAsync
     *
     * Gets a list of published services related to defined area and code.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The code related to area (required)
     * @param  bool $includeWholeCountry Indicates if services marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceAreaAreaCodeCodeGetAsync($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceAreaAreaCodeCodeGetAsyncWithHttpInfo
     *
     * Gets a list of published services related to defined area and code.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $area The area type (required)
     * @param  string $code The code related to area (required)
     * @param  bool $includeWholeCountry Indicates if services marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceAreaAreaCodeCodeGet'
     *
     * @param  string $area The area type (required)
     * @param  string $code The code related to area (required)
     * @param  bool $includeWholeCountry Indicates if services marked for whole country (or whole country except Åland) should be included. (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry = null, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'area' is set
        if ($area === null || (is_array($area) && count($area) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $area when calling apiV11ServiceAreaAreaCodeCodeGet'
            );
        }
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling apiV11ServiceAreaAreaCodeCodeGet'
            );
        }

        $resourcePath = '/api/v11/Service/area/{area}/code/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($includeWholeCountry !== null) {
            $queryParams['includeWholeCountry'] = ObjectSerializer::toQueryValue($includeWholeCountry, null);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($area !== null) {
            $resourcePath = str_replace(
                '{' . 'area' . '}',
                ObjectSerializer::toPathValue($area),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceGet
     *
     * Gets all the published services within PTV as a list of service ids and names.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceGet($date = null, $dateBefore = null, $page = '1', $status = 'Published')
    {
        list($response) = $this->apiV11ServiceGetWithHttpInfo($date, $dateBefore, $page, $status);
        return $response;
    }

    /**
     * Operation apiV11ServiceGetWithHttpInfo
     *
     * Gets all the published services within PTV as a list of service ids and names.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceGetWithHttpInfo($date = null, $dateBefore = null, $page = '1', $status = 'Published')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceGetRequest($date, $dateBefore, $page, $status);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceGetAsync
     *
     * Gets all the published services within PTV as a list of service ids and names.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceGetAsync($date = null, $dateBefore = null, $page = '1', $status = 'Published')
    {
        return $this->apiV11ServiceGetAsyncWithHttpInfo($date, $dateBefore, $page, $status)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceGetAsyncWithHttpInfo
     *
     * Gets all the published services within PTV as a list of service ids and names.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.  Archived items can be fetched by setting status parameter as 'Archived' and withdrawn items can be fetched by setting status parameter as 'Withdrawn'.
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceGetAsyncWithHttpInfo($date = null, $dateBefore = null, $page = '1', $status = 'Published')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceGetRequest($date, $dateBefore, $page, $status);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceGet'
     *
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     * @param  string $status Set status to get items either in published, archived or withdrawn state. (optional, default to Published)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceGetRequest($date = null, $dateBefore = null, $page = '1', $status = 'Published')
    {

        $resourcePath = '/api/v11/Service';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($status !== null) {
            $queryParams['status'] = ObjectSerializer::toQueryValue($status, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceIdGet
     *
     * Fetches all the information related to a single service.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService
     */
    public function apiV11ServiceIdGet($id, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceIdGetWithHttpInfo($id, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceIdGetWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceIdGetRequest($id, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceIdGetAsync
     *
     * Fetches all the information related to a single service.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceIdGetAsync($id, $showHeader = 'false')
    {
        return $this->apiV11ServiceIdGetAsyncWithHttpInfo($id, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceIdGetAsyncWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceIdGetRequest($id, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceIdGetRequest($id, $showHeader = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceIdGet'
            );
        }

        $resourcePath = '/api/v11/Service/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceIdPut
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $id Service identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService
     */
    public function apiV11ServiceIdPut($id, $body = null, $attachProposedChannels = null)
    {
        list($response) = $this->apiV11ServiceIdPutWithHttpInfo($id, $body, $attachProposedChannels);
        return $response;
    }

    /**
     * Operation apiV11ServiceIdPutWithHttpInfo
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $id Service identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceIdPutWithHttpInfo($id, $body = null, $attachProposedChannels = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceIdPutRequest($id, $body, $attachProposedChannels);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceIdPutAsync
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $id Service identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceIdPutAsync($id, $body = null, $attachProposedChannels = null)
    {
        return $this->apiV11ServiceIdPutAsyncWithHttpInfo($id, $body, $attachProposedChannels)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceIdPutAsyncWithHttpInfo
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $id Service identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceIdPutAsyncWithHttpInfo($id, $body = null, $attachProposedChannels = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceIdPutRequest($id, $body, $attachProposedChannels);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceIdPut'
     *
     * @param  string $id Service identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceIdPutRequest($id, $body = null, $attachProposedChannels = null)
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceIdPut'
            );
        }

        $resourcePath = '/api/v11/Service/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attachProposedChannels !== null) {
            $queryParams['attachProposedChannels'] = ObjectSerializer::toQueryValue($attachProposedChannels, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceIndustrialClassGet
     *
     * Gets a list of published services for defined industrial class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Industrial class uri, e.g. http://www.stat.fi/meta/luokitukset/toimiala/001-2008/46909 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceIndustrialClassGet($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceIndustrialClassGetWithHttpInfo($uri, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceIndustrialClassGetWithHttpInfo
     *
     * Gets a list of published services for defined industrial class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Industrial class uri, e.g. http://www.stat.fi/meta/luokitukset/toimiala/001-2008/46909 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceIndustrialClassGetWithHttpInfo($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceIndustrialClassGetRequest($uri, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceIndustrialClassGetAsync
     *
     * Gets a list of published services for defined industrial class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Industrial class uri, e.g. http://www.stat.fi/meta/luokitukset/toimiala/001-2008/46909 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceIndustrialClassGetAsync($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceIndustrialClassGetAsyncWithHttpInfo($uri, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceIndustrialClassGetAsyncWithHttpInfo
     *
     * Gets a list of published services for defined industrial class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Industrial class uri, e.g. http://www.stat.fi/meta/luokitukset/toimiala/001-2008/46909 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceIndustrialClassGetAsyncWithHttpInfo($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceIndustrialClassGetRequest($uri, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceIndustrialClassGet'
     *
     * @param  string $uri Industrial class uri, e.g. http://www.stat.fi/meta/luokitukset/toimiala/001-2008/46909 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceIndustrialClassGetRequest($uri = null, $date = null, $dateBefore = null, $page = '1')
    {

        $resourcePath = '/api/v11/Service/industrialClass';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($uri !== null) {
            $queryParams['uri'] = ObjectSerializer::toQueryValue($uri, null);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceListAreaAreaCodeCodeGet
     *
     * Fetches all the information of published services related to certain area and code.  User can set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $area The area type. (required)
     * @param  string $code The code related to area. (required)
     * @param  bool $includeWholeCountry Indicates if services marked to provide services for whole country (or whole country except Åland) should be included. (optional, default to false)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging
     */
    public function apiV11ServiceListAreaAreaCodeCodeGet($area, $code, $includeWholeCountry = 'false', $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceListAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry, $serviceWithGD, $page, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceListAreaAreaCodeCodeGetWithHttpInfo
     *
     * Fetches all the information of published services related to certain area and code.  User can set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $area The area type. (required)
     * @param  string $code The code related to area. (required)
     * @param  bool $includeWholeCountry Indicates if services marked to provide services for whole country (or whole country except Åland) should be included. (optional, default to false)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceListAreaAreaCodeCodeGetWithHttpInfo($area, $code, $includeWholeCountry = 'false', $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging';
        $request = $this->apiV11ServiceListAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $serviceWithGD, $page, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceListAreaAreaCodeCodeGetAsync
     *
     * Fetches all the information of published services related to certain area and code.  User can set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $area The area type. (required)
     * @param  string $code The code related to area. (required)
     * @param  bool $includeWholeCountry Indicates if services marked to provide services for whole country (or whole country except Åland) should be included. (optional, default to false)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceListAreaAreaCodeCodeGetAsync($area, $code, $includeWholeCountry = 'false', $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        return $this->apiV11ServiceListAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry, $serviceWithGD, $page, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceListAreaAreaCodeCodeGetAsyncWithHttpInfo
     *
     * Fetches all the information of published services related to certain area and code.  User can set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $area The area type. (required)
     * @param  string $code The code related to area. (required)
     * @param  bool $includeWholeCountry Indicates if services marked to provide services for whole country (or whole country except Åland) should be included. (optional, default to false)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceListAreaAreaCodeCodeGetAsyncWithHttpInfo($area, $code, $includeWholeCountry = 'false', $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging';
        $request = $this->apiV11ServiceListAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry, $serviceWithGD, $page, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceListAreaAreaCodeCodeGet'
     *
     * @param  string $area The area type. (required)
     * @param  string $code The code related to area. (required)
     * @param  bool $includeWholeCountry Indicates if services marked to provide services for whole country (or whole country except Åland) should be included. (optional, default to false)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceListAreaAreaCodeCodeGetRequest($area, $code, $includeWholeCountry = 'false', $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        // verify the required parameter 'area' is set
        if ($area === null || (is_array($area) && count($area) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $area when calling apiV11ServiceListAreaAreaCodeCodeGet'
            );
        }
        // verify the required parameter 'code' is set
        if ($code === null || (is_array($code) && count($code) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $code when calling apiV11ServiceListAreaAreaCodeCodeGet'
            );
        }

        $resourcePath = '/api/v11/Service/list/area/{area}/code/{code}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($includeWholeCountry !== null) {
            $queryParams['includeWholeCountry'] = ObjectSerializer::toQueryValue($includeWholeCountry, null);
        }
        // query params
        if ($serviceWithGD !== null) {
            $queryParams['serviceWithGD'] = ObjectSerializer::toQueryValue($serviceWithGD, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($area !== null) {
            $resourcePath = str_replace(
                '{' . 'area' . '}',
                ObjectSerializer::toPathValue($area),
                $resourcePath
            );
        }
        // path params
        if ($code !== null) {
            $resourcePath = str_replace(
                '{' . 'code' . '}',
                ObjectSerializer::toPathValue($code),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceListGet
     *
     * Fetches all the information related to requested services.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService[]
     */
    public function apiV11ServiceListGet($guids = null, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceListGetWithHttpInfo($guids, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceListGetWithHttpInfo
     *
     * Fetches all the information related to requested services.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceListGetWithHttpInfo($guids = null, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService[]';
        $request = $this->apiV11ServiceListGetRequest($guids, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceListGetAsync
     *
     * Fetches all the information related to requested services.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceListGetAsync($guids = null, $showHeader = 'false')
    {
        return $this->apiV11ServiceListGetAsyncWithHttpInfo($guids, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceListGetAsyncWithHttpInfo
     *
     * Fetches all the information related to requested services.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceListGetAsyncWithHttpInfo($guids = null, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService[]';
        $request = $this->apiV11ServiceListGetRequest($guids, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceListGet'
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceListGetRequest($guids = null, $showHeader = 'false')
    {

        $resourcePath = '/api/v11/Service/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($guids !== null) {
            $queryParams['guids'] = ObjectSerializer::toQueryValue($guids, null);
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceListOrganizationGet
     *
     * Fetches all the information of the services related to certain organization. Either organizationId, code or oid needs to be added as a parameter.  User can also set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging
     */
    public function apiV11ServiceListOrganizationGet($organizationId = null, $code = null, $oid = null, $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceListOrganizationGetWithHttpInfo($organizationId, $code, $oid, $serviceWithGD, $page, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceListOrganizationGetWithHttpInfo
     *
     * Fetches all the information of the services related to certain organization. Either organizationId, code or oid needs to be added as a parameter.  User can also set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceListOrganizationGetWithHttpInfo($organizationId = null, $code = null, $oid = null, $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging';
        $request = $this->apiV11ServiceListOrganizationGetRequest($organizationId, $code, $oid, $serviceWithGD, $page, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceListOrganizationGetAsync
     *
     * Fetches all the information of the services related to certain organization. Either organizationId, code or oid needs to be added as a parameter.  User can also set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceListOrganizationGetAsync($organizationId = null, $code = null, $oid = null, $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        return $this->apiV11ServiceListOrganizationGetAsyncWithHttpInfo($organizationId, $code, $oid, $serviceWithGD, $page, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceListOrganizationGetAsyncWithHttpInfo
     *
     * Fetches all the information of the services related to certain organization. Either organizationId, code or oid needs to be added as a parameter.  User can also set serviceWithGD parameter to true to include possible attached general description data into the service data.  In this case general description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceListOrganizationGetAsyncWithHttpInfo($organizationId = null, $code = null, $oid = null, $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiServicesWithPaging';
        $request = $this->apiV11ServiceListOrganizationGetRequest($organizationId, $code, $oid, $serviceWithGD, $page, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceListOrganizationGet'
     *
     * @param  string $organizationId Organization guid. (optional)
     * @param  string $code Organization business code. (optional)
     * @param  string $oid Organization oid. (optional)
     * @param  bool $serviceWithGD Indicates if general description data should be attached within the service data. (optional, default to false)
     * @param  int $page The page to be fetched. (optional, default to 1)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceListOrganizationGetRequest($organizationId = null, $code = null, $oid = null, $serviceWithGD = 'false', $page = '1', $showHeader = 'false')
    {

        $resourcePath = '/api/v11/Service/list/organization';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($organizationId !== null) {
            $queryParams['organizationId'] = ObjectSerializer::toQueryValue($organizationId, null);
        }
        // query params
        if ($code !== null) {
            $queryParams['code'] = ObjectSerializer::toQueryValue($code, null);
        }
        // query params
        if ($oid !== null) {
            $queryParams['oid'] = ObjectSerializer::toQueryValue($oid, null);
        }
        // query params
        if ($serviceWithGD !== null) {
            $queryParams['serviceWithGD'] = ObjectSerializer::toQueryValue($serviceWithGD, null);
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServicePost
     *
     * Creates a new service with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceIn $body The service data. (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService
     */
    public function apiV11ServicePost($body = null, $attachProposedChannels = null)
    {
        list($response) = $this->apiV11ServicePostWithHttpInfo($body, $attachProposedChannels);
        return $response;
    }

    /**
     * Operation apiV11ServicePostWithHttpInfo
     *
     * Creates a new service with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceIn $body The service data. (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServicePostWithHttpInfo($body = null, $attachProposedChannels = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServicePostRequest($body, $attachProposedChannels);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServicePostAsync
     *
     * Creates a new service with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceIn $body The service data. (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServicePostAsync($body = null, $attachProposedChannels = null)
    {
        return $this->apiV11ServicePostAsyncWithHttpInfo($body, $attachProposedChannels)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServicePostAsyncWithHttpInfo
     *
     * Creates a new service with the data provided as input.
     *
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceIn $body The service data. (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServicePostAsyncWithHttpInfo($body = null, $attachProposedChannels = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServicePostRequest($body, $attachProposedChannels);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServicePost'
     *
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceIn $body The service data. (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServicePostRequest($body = null, $attachProposedChannels = null)
    {

        $resourcePath = '/api/v11/Service';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attachProposedChannels !== null) {
            $queryParams['attachProposedChannels'] = ObjectSerializer::toQueryValue($attachProposedChannels, null);
        }


        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'POST',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceServiceChannelServiceChannelIdGet
     *
     * Gets a list of published services for defined service channel.  Services joined to service channel after certain date can be fetched by adding date as query string parameter.  Services joined to service channel before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $serviceChannelId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceServiceChannelServiceChannelIdGet($serviceChannelId, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceServiceChannelServiceChannelIdGetWithHttpInfo($serviceChannelId, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceServiceChannelServiceChannelIdGetWithHttpInfo
     *
     * Gets a list of published services for defined service channel.  Services joined to service channel after certain date can be fetched by adding date as query string parameter.  Services joined to service channel before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $serviceChannelId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceServiceChannelServiceChannelIdGetWithHttpInfo($serviceChannelId, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceServiceChannelServiceChannelIdGetRequest($serviceChannelId, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceServiceChannelServiceChannelIdGetAsync
     *
     * Gets a list of published services for defined service channel.  Services joined to service channel after certain date can be fetched by adding date as query string parameter.  Services joined to service channel before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $serviceChannelId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceChannelServiceChannelIdGetAsync($serviceChannelId, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceServiceChannelServiceChannelIdGetAsyncWithHttpInfo($serviceChannelId, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceServiceChannelServiceChannelIdGetAsyncWithHttpInfo
     *
     * Gets a list of published services for defined service channel.  Services joined to service channel after certain date can be fetched by adding date as query string parameter.  Services joined to service channel before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $serviceChannelId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceChannelServiceChannelIdGetAsyncWithHttpInfo($serviceChannelId, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceServiceChannelServiceChannelIdGetRequest($serviceChannelId, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceServiceChannelServiceChannelIdGet'
     *
     * @param  string $serviceChannelId Guid (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceServiceChannelServiceChannelIdGetRequest($serviceChannelId, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'serviceChannelId' is set
        if ($serviceChannelId === null || (is_array($serviceChannelId) && count($serviceChannelId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $serviceChannelId when calling apiV11ServiceServiceChannelServiceChannelIdGet'
            );
        }

        $resourcePath = '/api/v11/Service/serviceChannel/{serviceChannelId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($serviceChannelId !== null) {
            $resourcePath = str_replace(
                '{' . 'serviceChannelId' . '}',
                ObjectSerializer::toPathValue($serviceChannelId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceServiceClassGet
     *
     * Gets a list of published services for defined service class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Service class uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v1065 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceServiceClassGet($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceServiceClassGetWithHttpInfo($uri, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceServiceClassGetWithHttpInfo
     *
     * Gets a list of published services for defined service class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Service class uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v1065 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceServiceClassGetWithHttpInfo($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceServiceClassGetRequest($uri, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceServiceClassGetAsync
     *
     * Gets a list of published services for defined service class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Service class uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v1065 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceClassGetAsync($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceServiceClassGetAsyncWithHttpInfo($uri, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceServiceClassGetAsyncWithHttpInfo
     *
     * Gets a list of published services for defined service class.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Service class uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v1065 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceClassGetAsyncWithHttpInfo($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceServiceClassGetRequest($uri, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceServiceClassGet'
     *
     * @param  string $uri Service class uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v1065 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceServiceClassGetRequest($uri = null, $date = null, $dateBefore = null, $page = '1')
    {

        $resourcePath = '/api/v11/Service/serviceClass';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($uri !== null) {
            $queryParams['uri'] = ObjectSerializer::toQueryValue($uri, null);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceServiceWithGDIdGet
     *
     * Fetches all the information related to a single service. If general description is attached also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService
     */
    public function apiV11ServiceServiceWithGDIdGet($id, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceServiceWithGDIdGetWithHttpInfo($id, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceServiceWithGDIdGetWithHttpInfo
     *
     * Fetches all the information related to a single service. If general description is attached also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceServiceWithGDIdGetWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceServiceWithGDIdGetRequest($id, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceServiceWithGDIdGetAsync
     *
     * Fetches all the information related to a single service. If general description is attached also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceWithGDIdGetAsync($id, $showHeader = 'false')
    {
        return $this->apiV11ServiceServiceWithGDIdGetAsyncWithHttpInfo($id, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceServiceWithGDIdGetAsyncWithHttpInfo
     *
     * Fetches all the information related to a single service. If general description is attached also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceWithGDIdGetAsyncWithHttpInfo($id, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceServiceWithGDIdGetRequest($id, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceServiceWithGDIdGet'
     *
     * @param  string $id Guid (required)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceServiceWithGDIdGetRequest($id, $showHeader = 'false')
    {
        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling apiV11ServiceServiceWithGDIdGet'
            );
        }

        $resourcePath = '/api/v11/Service/serviceWithGD/{id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }

        // path params
        if ($id !== null) {
            $resourcePath = str_replace(
                '{' . 'id' . '}',
                ObjectSerializer::toPathValue($id),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceServiceWithGDListGet
     *
     * Fetches all the information related to requests services. If general description is attached to a service also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService[]
     */
    public function apiV11ServiceServiceWithGDListGet($guids = null, $showHeader = 'false')
    {
        list($response) = $this->apiV11ServiceServiceWithGDListGetWithHttpInfo($guids, $showHeader);
        return $response;
    }

    /**
     * Operation apiV11ServiceServiceWithGDListGetWithHttpInfo
     *
     * Fetches all the information related to requests services. If general description is attached to a service also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService[], HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceServiceWithGDListGetWithHttpInfo($guids = null, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService[]';
        $request = $this->apiV11ServiceServiceWithGDListGetRequest($guids, $showHeader);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService[]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceServiceWithGDListGetAsync
     *
     * Fetches all the information related to requests services. If general description is attached to a service also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceWithGDListGetAsync($guids = null, $showHeader = 'false')
    {
        return $this->apiV11ServiceServiceWithGDListGetAsyncWithHttpInfo($guids, $showHeader)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceServiceWithGDListGetAsyncWithHttpInfo
     *
     * Fetches all the information related to requests services. If general description is attached to a service also general description data is returned within the service data.  General description related descriptions are marked with prefix 'GD_' to separate them from service related descriptions.
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceServiceWithGDListGetAsyncWithHttpInfo($guids = null, $showHeader = 'false')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService[]';
        $request = $this->apiV11ServiceServiceWithGDListGetRequest($guids, $showHeader);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceServiceWithGDListGet'
     *
     * @param  string $guids Comma separated list of guids. Max 100 can be added into list. (optional)
     * @param  bool $showHeader (optional, default to false)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceServiceWithGDListGetRequest($guids = null, $showHeader = 'false')
    {

        $resourcePath = '/api/v11/Service/serviceWithGD/list';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($guids !== null) {
            $queryParams['guids'] = ObjectSerializer::toQueryValue($guids, null);
        }
        // query params
        if ($showHeader !== null) {
            $queryParams['showHeader'] = ObjectSerializer::toQueryValue($showHeader, null);
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceSourceIdSourceIdPut
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V11VmOpenApiService
     */
    public function apiV11ServiceSourceIdSourceIdPut($sourceId, $body = null, $attachProposedChannels = null)
    {
        list($response) = $this->apiV11ServiceSourceIdSourceIdPutWithHttpInfo($sourceId, $body, $attachProposedChannels);
        return $response;
    }

    /**
     * Operation apiV11ServiceSourceIdSourceIdPutWithHttpInfo
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V11VmOpenApiService, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceSourceIdSourceIdPutWithHttpInfo($sourceId, $body = null, $attachProposedChannels = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceSourceIdSourceIdPutRequest($sourceId, $body, $attachProposedChannels);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V11VmOpenApiService',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceSourceIdSourceIdPutAsync
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceSourceIdSourceIdPutAsync($sourceId, $body = null, $attachProposedChannels = null)
    {
        return $this->apiV11ServiceSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body, $attachProposedChannels)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceSourceIdSourceIdPutAsyncWithHttpInfo
     *
     * Updates the defined service with the data provided as input.
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceSourceIdSourceIdPutAsyncWithHttpInfo($sourceId, $body = null, $attachProposedChannels = null)
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V11VmOpenApiService';
        $request = $this->apiV11ServiceSourceIdSourceIdPutRequest($sourceId, $body, $attachProposedChannels);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceSourceIdSourceIdPut'
     *
     * @param  string $sourceId External source identifier (required)
     * @param  \Tampere\PtvV11\PtvModel\V9VmOpenApiServiceInBase $body The service data (optional)
     * @param  bool $attachProposedChannels Indicates if service channels attached into general description should automatically be attached into the service. (optional)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceSourceIdSourceIdPutRequest($sourceId, $body = null, $attachProposedChannels = null)
    {
        // verify the required parameter 'sourceId' is set
        if ($sourceId === null || (is_array($sourceId) && count($sourceId) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $sourceId when calling apiV11ServiceSourceIdSourceIdPut'
            );
        }

        $resourcePath = '/api/v11/Service/sourceId/{sourceId}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($attachProposedChannels !== null) {
            $queryParams['attachProposedChannels'] = ObjectSerializer::toQueryValue($attachProposedChannels, null);
        }

        // path params
        if ($sourceId !== null) {
            $resourcePath = str_replace(
                '{' . 'sourceId' . '}',
                ObjectSerializer::toPathValue($sourceId),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;
        if (isset($body)) {
            $_tempBody = $body;
        }

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                ['application/json-patch+json', 'application/json', 'text/json', 'application/_*+json']
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }

        // this endpoint requires OAuth (access token)
        if ($this->config->getAccessToken() !== null) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'PUT',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceTargetGroupGet
     *
     * Gets a list of published services for defined target group.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Target group uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v2001 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceTargetGroupGet($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceTargetGroupGetWithHttpInfo($uri, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceTargetGroupGetWithHttpInfo
     *
     * Gets a list of published services for defined target group.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Target group uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v2001 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceTargetGroupGetWithHttpInfo($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceTargetGroupGetRequest($uri, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceTargetGroupGetAsync
     *
     * Gets a list of published services for defined target group.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Target group uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v2001 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceTargetGroupGetAsync($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceTargetGroupGetAsyncWithHttpInfo($uri, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceTargetGroupGetAsyncWithHttpInfo
     *
     * Gets a list of published services for defined target group.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $uri Target group uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v2001 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceTargetGroupGetAsyncWithHttpInfo($uri = null, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceTargetGroupGetRequest($uri, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceTargetGroupGet'
     *
     * @param  string $uri Target group uri, e.g. http://urn.fi/URN:NBN:fi:au:ptvl:v2001 (optional)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceTargetGroupGetRequest($uri = null, $date = null, $dateBefore = null, $page = '1')
    {

        $resourcePath = '/api/v11/Service/targetGroup';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($uri !== null) {
            $queryParams['uri'] = ObjectSerializer::toQueryValue($uri, null);
        }
        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }


        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation apiV11ServiceTypeTypeGet
     *
     * Gets a list of published services of defined service type.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage
     */
    public function apiV11ServiceTypeTypeGet($type, $date = null, $dateBefore = null, $page = '1')
    {
        list($response) = $this->apiV11ServiceTypeTypeGetWithHttpInfo($type, $date, $dateBefore, $page);
        return $response;
    }

    /**
     * Operation apiV11ServiceTypeTypeGetWithHttpInfo
     *
     * Gets a list of published services of defined service type.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \Tampere\PtvV11\ApiException on non-2xx response
     * @throws \InvalidArgumentException
     * @return array of \Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage, HTTP status code, HTTP response headers (array of strings)
     */
    public function apiV11ServiceTypeTypeGetWithHttpInfo($type, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceTypeTypeGetRequest($type, $date, $dateBefore, $page);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? $e->getResponse()->getBody()->getContents() : null
                );
            }

            $statusCode = $response->getStatusCode();

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    $response->getBody()
                );
            }

            $responseBody = $response->getBody();
            if ($returnType === '\SplFileObject') {
                $content = $responseBody; //stream goes to serializer
            } else {
                $content = $responseBody->getContents();
                if (!in_array($returnType, ['string','integer','bool'])) {
                    $content = json_decode($content);
                }
            }

            return [
                ObjectSerializer::deserialize($content, $returnType, []),
                $response->getStatusCode(),
                $response->getHeaders()
            ];

        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 400:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        'map[string,string[]]',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\Tampere\PtvV11\PtvModel\IVmError',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    break;
            }
            throw $e;
        }
    }

    /**
     * Operation apiV11ServiceTypeTypeGetAsync
     *
     * Gets a list of published services of defined service type.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceTypeTypeGetAsync($type, $date = null, $dateBefore = null, $page = '1')
    {
        return $this->apiV11ServiceTypeTypeGetAsyncWithHttpInfo($type, $date, $dateBefore, $page)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation apiV11ServiceTypeTypeGetAsyncWithHttpInfo
     *
     * Gets a list of published services of defined service type.  Services created/modified after certain date can be fetched by adding date as query string parameter.  Services created/modified before certain date can be fetched by adding dateBefore as query string parameter.
     *
     * @param  string $type Service type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function apiV11ServiceTypeTypeGetAsyncWithHttpInfo($type, $date = null, $dateBefore = null, $page = '1')
    {
        $returnType = '\Tampere\PtvV11\PtvModel\V3VmOpenApiGuidPage';
        $request = $this->apiV11ServiceTypeTypeGetRequest($type, $date, $dateBefore, $page);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    $responseBody = $response->getBody();
                    if ($returnType === '\SplFileObject') {
                        $content = $responseBody; //stream goes to serializer
                    } else {
                        $content = $responseBody->getContents();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'apiV11ServiceTypeTypeGet'
     *
     * @param  string $type Service type (required)
     * @param  \DateTime $date Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  \DateTime $dateBefore Supports only format \&quot;yyyy-MM-ddTHH:mm:ss\&quot; (UTC). (optional)
     * @param  int $page The page number to be fetched. (optional, default to 1)
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    protected function apiV11ServiceTypeTypeGetRequest($type, $date = null, $dateBefore = null, $page = '1')
    {
        // verify the required parameter 'type' is set
        if ($type === null || (is_array($type) && count($type) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $type when calling apiV11ServiceTypeTypeGet'
            );
        }

        $resourcePath = '/api/v11/Service/type/{type}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        if ($date !== null) {
            $queryParams['date'] = ObjectSerializer::toQueryValue($date, 'date-time');
        }
        // query params
        if ($dateBefore !== null) {
            $queryParams['dateBefore'] = ObjectSerializer::toQueryValue($dateBefore, 'date-time');
        }
        // query params
        if ($page !== null) {
            $queryParams['page'] = ObjectSerializer::toQueryValue($page, 'int32');
        }

        // path params
        if ($type !== null) {
            $resourcePath = str_replace(
                '{' . 'type' . '}',
                ObjectSerializer::toPathValue($type),
                $resourcePath
            );
        }

        // body params
        $_tempBody = null;

        if ($multipart) {
            $headers = $this->headerSelector->selectHeadersForMultipart(
                ['text/plain', 'application/json', 'text/json']
            );
        } else {
            $headers = $this->headerSelector->selectHeaders(
                ['text/plain', 'application/json', 'text/json'],
                []
            );
        }

        // for model (json/xml)
        if (isset($_tempBody)) {
            // $_tempBody is the method argument, if present
            $httpBody = $_tempBody;
            // \stdClass has no __toString(), so we should encode it manually
            if ($httpBody instanceof \stdClass && $headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($httpBody);
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $multipartContents[] = [
                        'name' => $formParamName,
                        'contents' => $formParamValue
                    ];
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif ($headers['Content-Type'] === 'application/json') {
                $httpBody = \GuzzleHttp\json_encode($formParams);

            } else {
                // for HTTP post (form)
                $httpBody = \GuzzleHttp\Psr7\build_query($formParams);
            }
        }


        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $query = \GuzzleHttp\Psr7\build_query($queryParams);
        return new Request(
            'GET',
            $this->config->getHost() . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        return $options;
    }
}
